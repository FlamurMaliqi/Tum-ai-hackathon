<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Comstruct WS 5s Text Demo</title>
    <style>
      :root { color-scheme: light dark; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; max-width: 980px; }
      .row { display: flex; gap: 10px; flex-wrap: wrap; margin: 12px 0; align-items: center; }
      input { padding: 10px; min-width: 520px; }
      button { padding: 10px 12px; cursor: pointer; }
      pre { background: #0b1020; color: #dbe7ff; padding: 12px; border-radius: 8px; overflow: auto; min-height: 280px; }
      code { background: rgba(127,127,127,0.12); padding: 2px 6px; border-radius: 6px; }
      .muted { color: #666; font-size: 12px; line-height: 1.35; }
      .pill { display: inline-block; padding: 3px 8px; border-radius: 999px; background: rgba(127,127,127,0.12); font-size: 12px; }
    </style>
  </head>
  <body>
    <h2>WebSocket “5 seconds of human text” demo</h2>
    <div class="muted">
      This page connects to your FastAPI WebSocket endpoint
      <code>/api/v1/websocket/</code> and sends ~5 seconds of text as a construction supervisor ordering
      <b>5 glove pairs (German: Handschuh)</b> to your voice agent server.
    </div>

    <div class="row">
      <span class="pill">WS URL</span>
      <input id="wsUrlInput" />
    </div>

    <div class="row">
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
      <button id="runDemoBtn" disabled>Run 5s supervisor order</button>
      <button id="interruptBtn" disabled>Interrupt</button>
      <button id="clearBtn">Clear log</button>
    </div>

    <div class="row">
      <span class="pill">Chat</span>
      <input id="chatInput" placeholder="Type a message…" disabled />
      <button id="sendBtn" disabled>Send</button>
    </div>

    <div class="row">
      <span class="pill">Audio</span>
      <audio id="ttsAudio" controls style="min-width: 520px"></audio>
      <button id="stopAudioBtn" disabled>Stop audio</button>
      <button id="clearAudioBtn" disabled>Clear audio</button>
    </div>

    <pre id="log"></pre>

    <script>
      const logEl = document.getElementById("log");
      const connectBtn = document.getElementById("connectBtn");
      const disconnectBtn = document.getElementById("disconnectBtn");
      const runDemoBtn = document.getElementById("runDemoBtn");
      const interruptBtn = document.getElementById("interruptBtn");
      const clearBtn = document.getElementById("clearBtn");
      const wsUrlInput = document.getElementById("wsUrlInput");
      const chatInput = document.getElementById("chatInput");
      const sendBtn = document.getElementById("sendBtn");
      const ttsAudio = document.getElementById("ttsAudio");
      const stopAudioBtn = document.getElementById("stopAudioBtn");
      const clearAudioBtn = document.getElementById("clearAudioBtn");

      const DEMO_LINES = [
        "Hey, this is Mike, the construction site supervisor at the Riverside job.",
        "I need to order five pairs of gloves — in German, Handschuh.",
        "Before we place the order, please check our inventory to see if we already have any in stock.",
        "If we don’t have enough, please find the best price to buy five pairs and tell me the supplier and total cost.",
        "Once you’ve checked, confirm what you’re going to do next and how soon we can get them on site."
      ];

      let ws = null;
      let demoTimeouts = [];

      // ---- TTS playback (Chrome-friendly streaming) ----
      let mediaSource = null;
      let sourceBuffer = null;
      let mediaSourceUrl = null;
      let audioQueue = [];
      let usingMse = false;
      let msePending = false;
      let mseFailed = false;
      let fallbackChunks = [];
      let fallbackUrl = null;

      function canUseMseMp3() {
        return (
          typeof window.MediaSource !== "undefined" &&
          typeof window.MediaSource.isTypeSupported === "function" &&
          window.MediaSource.isTypeSupported("audio/mpeg")
        );
      }

      function pauseAndDetachAudio() {
        try {
          ttsAudio.pause();
        } catch {}

        // Detach any current source.
        ttsAudio.removeAttribute("src");
        try {
          ttsAudio.load();
        } catch {}
      }

      function revokeUrls() {
        if (mediaSourceUrl) {
          try {
            URL.revokeObjectURL(mediaSourceUrl);
          } catch {}
          mediaSourceUrl = null;
        }
        if (fallbackUrl) {
          try {
            URL.revokeObjectURL(fallbackUrl);
          } catch {}
          fallbackUrl = null;
        }
      }

      function resetTtsPlayback(reason = "reset") {
        audioQueue = [];
        fallbackChunks = [];
        usingMse = false;
        msePending = false;
        mseFailed = false;

        // Try to gracefully end MSE if open.
        try {
          if (mediaSource && mediaSource.readyState === "open") {
            mediaSource.endOfStream();
          }
        } catch {}

        sourceBuffer = null;
        mediaSource = null;

        pauseAndDetachAudio();
        revokeUrls();
        log("tts:", reason);
      }

      function pumpMseQueue() {
        if (!usingMse || !sourceBuffer) return;
        if (sourceBuffer.updating) return;
        if (!audioQueue.length) return;

        const next = audioQueue.shift();
        try {
          sourceBuffer.appendBuffer(next);
        } catch (e) {
          log("tts: mse append failed; switching to fallback:", String(e));
          usingMse = false;
          mseFailed = true;
        }
      }

      function startTtsSession() {
        resetTtsPlayback("tts session start");

        if (!canUseMseMp3()) {
          mseFailed = true;
          log("tts: MediaSource audio/mpeg not supported; using fallback");
          return;
        }

        try {
          mediaSource = new MediaSource();
          mediaSourceUrl = URL.createObjectURL(mediaSource);
          ttsAudio.src = mediaSourceUrl;
          msePending = true;

          mediaSource.addEventListener("sourceopen", () => {
            try {
              sourceBuffer = mediaSource.addSourceBuffer("audio/mpeg");
              // In-order append is ideal for streamed MP3 chunks.
              try {
                sourceBuffer.mode = "sequence";
              } catch {}
              sourceBuffer.addEventListener("updateend", () => pumpMseQueue());
              usingMse = true;
              msePending = false;
              log("tts: mse sourceopen; ready");
              pumpMseQueue();
            } catch (e) {
              log("tts: addSourceBuffer failed; using fallback:", String(e));
              usingMse = false;
              msePending = false;
              mseFailed = true;
            }
          });
        } catch (e) {
          log("tts: mse init failed; using fallback:", String(e));
          usingMse = false;
          msePending = false;
          mseFailed = true;
        }
      }

      function onTtsBinaryChunk(arrayBuffer) {
        // Always accumulate fallback bytes so we can still play something
        // if streaming fails midway.
        fallbackChunks.push(arrayBuffer);

        // If MSE is available but not ready yet (sourceopen pending), queue now.
        if ((usingMse || msePending) && mediaSource && !mseFailed) {
          audioQueue.push(arrayBuffer);

          if (usingMse && sourceBuffer && mediaSource.readyState === "open") {
            pumpMseQueue();
            // Autoplay (best effort) once we have data.
            if (ttsAudio.paused) ttsAudio.play().catch(() => {});
          }
          return;
        }
      }

      function finalizeTtsSession() {
        if (mediaSource && !mseFailed && (usingMse || msePending)) {
          // Drain any pending appends first.
          const start = Date.now();
          const tryFinalize = () => {
            if (!mediaSource || mseFailed) return;
            if (msePending && !sourceBuffer) {
              if (Date.now() - start > 2000) {
                log("tts: mse never opened; falling back to post-response playback");
                usingMse = false;
                msePending = false;
                mseFailed = true;
                finalizeTtsSession();
                return;
              }
              setTimeout(tryFinalize, 50);
              return;
            }
            if (sourceBuffer && (sourceBuffer.updating || audioQueue.length)) {
              pumpMseQueue();
              setTimeout(tryFinalize, 50);
              return;
            }
            try {
              if (mediaSource.readyState === "open") mediaSource.endOfStream();
            } catch {}
            log("tts: mse ended");
          };
          tryFinalize();
          return;
        }

        // Fallback: play after done.
        if (!fallbackChunks.length) {
          log("tts: no audio received");
          return;
        }

        try {
          const blob = new Blob(fallbackChunks, { type: "audio/mpeg" });
          revokeUrls();
          fallbackUrl = URL.createObjectURL(blob);
          ttsAudio.src = fallbackUrl;
          ttsAudio.play().catch(() => {});
          log("tts: fallback playing (post-response)");
        } catch (e) {
          log("tts: fallback failed:", String(e));
        }
      }

      function log(...args) {
        const line = args.map((a) => (typeof a === "string" ? a : JSON.stringify(a))).join(" ");
        logEl.textContent += line + "\n";
        logEl.scrollTop = logEl.scrollHeight;
        console.log(...args);
      }

      function defaultWsUrl() {
        const proto = window.location.protocol === "https:" ? "wss" : "ws";
        return `${proto}://localhost:8000/api/v1/websocket/`;
      }

      function setConnected(connected) {
        disconnectBtn.disabled = !connected;
        runDemoBtn.disabled = !connected;
        interruptBtn.disabled = !connected;
        chatInput.disabled = !connected;
        sendBtn.disabled = !connected;
        stopAudioBtn.disabled = !connected;
        clearAudioBtn.disabled = !connected;
      }

      function clearDemoTimers() {
        for (const t of demoTimeouts) clearTimeout(t);
        demoTimeouts = [];
      }

      function sendJson(obj) {
        if (!ws || ws.readyState !== WebSocket.OPEN) return false;
        ws.send(JSON.stringify(obj));
        return true;
      }

      function connect() {
        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;

        const url = wsUrlInput.value.trim() || defaultWsUrl();
        log("connecting:", url);

        ws = new WebSocket(url);
        ws.binaryType = "arraybuffer";

        ws.addEventListener("open", () => {
          log("open");
          setConnected(true);
        });

        ws.addEventListener("close", (ev) => {
          log("close:", { code: ev.code, reason: ev.reason });
          setConnected(false);
          clearDemoTimers();
          resetTtsPlayback("ws closed");
        });

        ws.addEventListener("error", () => {
          log("error");
        });

        ws.addEventListener("message", (event) => {
          if (typeof event.data === "string") {
            try {
              const msg = JSON.parse(event.data);
              log("json:", msg);

              // Lifecycle hooks to sync audio with assistant streaming.
              if (msg && typeof msg.type === "string") {
                if (msg.type === "assistant_start") startTtsSession();
                if (msg.type === "assistant_done") finalizeTtsSession();
                if (msg.type === "stream_cancelled") resetTtsPlayback("stream cancelled");
                if (msg.type === "assistant_error") resetTtsPlayback("assistant error");
              }
            } catch {
              log("text:", event.data);
            }
            return;
          }

          if (event.data instanceof ArrayBuffer) {
            log("binary:", { bytes: event.data.byteLength });
            onTtsBinaryChunk(event.data);
            return;
          }

          if (event.data instanceof Blob) {
            log("binary(blob):", { bytes: event.data.size });
            event.data
              .arrayBuffer()
              .then((buf) => onTtsBinaryChunk(buf))
              .catch((e) => log("tts: blob->arrayBuffer failed:", String(e)));
            return;
          }

          log("unknown message type:", typeof event.data);
        });
      }

      async function ensureConnected() {
        if (ws && ws.readyState === WebSocket.OPEN) return;
        connect();
        await new Promise((resolve, reject) => {
          const start = Date.now();
          const tick = () => {
            if (ws && ws.readyState === WebSocket.OPEN) return resolve();
            if (ws && ws.readyState === WebSocket.CLOSED) return reject(new Error("WebSocket closed"));
            if (Date.now() - start > 4000) return reject(new Error("Timed out waiting for WebSocket open"));
            setTimeout(tick, 25);
          };
          tick();
        });
      }

      function runDemo5Seconds() {
        clearDemoTimers();

        log("--- demo: supervisor ordering 5 glove pairs (about 5 seconds) ---");

        // Send one sentence per ~1s (5 sentences ≈ 5 seconds).
        DEMO_LINES.forEach((line, i) => {
          const delayMs = i * 1000;
          const t = setTimeout(() => {
            log("demo → user_message:", line);
            sendJson({ type: "user_message", text: line });
          }, delayMs);
          demoTimeouts.push(t);
        });
      }

      function sendChatMessage() {
        const text = (chatInput.value || "").trim();
        if (!text) return;
        if (!ws || ws.readyState !== WebSocket.OPEN) {
          log("not connected; cannot send");
          return;
        }
        log("chat → user_message:", text);
        sendJson({ type: "user_message", text });
        chatInput.value = "";
        chatInput.focus();
      }

      // Init
      wsUrlInput.value = defaultWsUrl();
      setConnected(false);

      // UI handlers
      connectBtn.addEventListener("click", () => connect());

      disconnectBtn.addEventListener("click", () => {
        clearDemoTimers();
        if (!ws) return;
        log("disconnecting…");
        ws.close(1000, "client closed");
      });

      runDemoBtn.addEventListener("click", async () => {
        try {
          await ensureConnected();
          runDemo5Seconds();
        } catch (e) {
          log("demo failed:", String(e && e.message ? e.message : e));
        }
      });

      interruptBtn.addEventListener("click", () => {
        log("interrupt → sending interrupt");
        resetTtsPlayback("interrupt (local)");
        sendJson({ type: "interrupt" });
      });

      clearBtn.addEventListener("click", () => {
        logEl.textContent = "";
      });

      stopAudioBtn.addEventListener("click", () => {
        try {
          ttsAudio.pause();
        } catch {}
        log("tts: paused");
      });

      clearAudioBtn.addEventListener("click", () => {
        resetTtsPlayback("audio cleared");
      });

      sendBtn.addEventListener("click", () => sendChatMessage());
      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendChatMessage();
        }
      });
    </script>
  </body>
</html>

